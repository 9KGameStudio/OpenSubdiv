<!DOCTYPE html>  <html> <head>   <title>simpleCpuSubdivision.cpp</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               simpleCpuSubdivision.cpp             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>               <h2>CPU Subdivision with OpenSubdiv </h2>

<p>In this example program, we will setup an OpenGL application that uses OSD to
subdivide an animated mesh. It is intended to be as simple as possible and 
not necessarily efficient. It is also intended as a learning tool for 
understanding the OSD internals. Unlike the other OSD examples, the common 
code infrastructure has been removed for clarity.</p>

<h3>Program Structure</h3>

<p>This example program is structured as follows:</p>

<ol>
<li>Setup static mesh topology (OsdHbrMesh)</li>
<li>Convert the topology into a subdividable mesh (OsdMesh)</li>
<li>On each frame: 
<ul><li>Animate the coarse mesh points and update the OsdMesh</li>
<li>Subdivide the updated mesh</li>
<li>Draw the subdivided mesh and wire frame</li></ul></li>
</ol>

<p>If you are completely new to OSD, you should read the following sections to 
get a basic understanding of how it works.</p>

<h3>OSD Architecture Basics</h3>

<p>As a client, you will primarily be interacting with the Osd and Hbr classes, 
however it's good to be aware of all three layers. The following describes
these layers from lowest level (Hbr) to highest (Osd):</p>

<p><strong>Hbr: Halfedge Boundary Representation.</strong>
This layer represents the mesh topology as meshes, vertices and edges. It is
the core that provides the structure for subdivision and provides an 
abstraction for dealing with topology in a type-agnostic way (i.e. everything
is templated).</p>

<p><strong>Far: Feature Adaptive Representation.</strong> 
Far uses hbr to create and cache fast run time data structures for table 
driven subdivision. Feature-adaptive refinement logic is used to adaptively 
refine coarse topology only as much as needed. The FarMesh does hold vertex 
objects but the topology has been baked into FarSubdivisionTables. It also
provides the underpinnings for generic dispatch of subdivision evaluation, so
subdivision can be preformed with different mechanisms (GLSL, Cuda, etc.),
the concrete implementations are specified at the next layer up.</p>

<p><strong>Osd: Open Subdiv.</strong>
Osd contains client level code that uses Far to create concrete instances of 
meshes and compute patch CVs with different back ends for table driven 
subdivision. Currently, the following are supported in Osd:</p>

<ul>
<li>CPU / C++ with single or multiple threads </li>
<li>GLSL kernels with transform feedback into VBOs </li>
<li>OpenCL kernels </li>
<li>CUDA kernels</li>
</ul>

<p>The amount of hardware specific computation code is small, ~300 lines of code,
so it isn't a large effort to support multiple different ones for different 
clients. In the future, it is conceivable that additional dispatchers will be
developed to target mobile devices.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">Copyright (C) Pixar. All rights reserved.</span>

<span class="cm">This license governs use of the accompanying software. If you</span>
<span class="cm">use the software, you accept this license. If you do not accept</span>
<span class="cm">the license, do not use the software.</span>

<span class="cm">1. Definitions</span>
<span class="cm">The terms &quot;reproduce,&quot; &quot;reproduction,&quot; &quot;derivative works,&quot; and</span>
<span class="cm">&quot;distribution&quot; have the same meaning here as under U.S.</span>
<span class="cm">copyright law.  A &quot;contribution&quot; is the original software, or</span>
<span class="cm">any additions or changes to the software.</span>
<span class="cm">A &quot;contributor&quot; is any person or entity that distributes its</span>
<span class="cm">contribution under this license.</span>
<span class="cm">&quot;Licensed patents&quot; are a contributor&#39;s patent claims that read</span>
<span class="cm">directly on its contribution.</span>

<span class="cm">2. Grant of Rights</span>
<span class="cm">(A) Copyright Grant- Subject to the terms of this license,</span>
<span class="cm">including the license conditions and limitations in section 3,</span>
<span class="cm">each contributor grants you a non-exclusive, worldwide,</span>
<span class="cm">royalty-free copyright license to reproduce its contribution,</span>
<span class="cm">prepare derivative works of its contribution, and distribute</span>
<span class="cm">its contribution or any derivative works that you create.</span>
<span class="cm">(B) Patent Grant- Subject to the terms of this license,</span>
<span class="cm">including the license conditions and limitations in section 3,</span>
<span class="cm">each contributor grants you a non-exclusive, worldwide,</span>
<span class="cm">royalty-free license under its licensed patents to make, have</span>
<span class="cm">made, use, sell, offer for sale, import, and/or otherwise</span>
<span class="cm">dispose of its contribution in the software or derivative works</span>
<span class="cm">of the contribution in the software.</span>

<span class="cm">3. Conditions and Limitations</span>
<span class="cm">(A) No Trademark License- This license does not grant you</span>
<span class="cm">rights to use any contributor&#39;s name, logo, or trademarks.</span>
<span class="cm">(B) If you bring a patent claim against any contributor over</span>
<span class="cm">patents that you claim are infringed by the software, your</span>
<span class="cm">patent license from such contributor to the software ends</span>
<span class="cm">automatically.</span>
<span class="cm">(C) If you distribute any portion of the software, you must</span>
<span class="cm">retain all copyright, patent, trademark, and attribution</span>
<span class="cm">notices that are present in the software.</span>
<span class="cm">(D) If you distribute any portion of the software in source</span>
<span class="cm">code form, you may do so only under this license by including a</span>
<span class="cm">complete copy of this license with your distribution. If you</span>
<span class="cm">distribute any portion of the software in compiled or object</span>
<span class="cm">code form, you may only do so under a license that complies</span>
<span class="cm">with this license.</span>
<span class="cm">(E) The software is licensed &quot;as-is.&quot; You bear the risk of</span>
<span class="cm">using it. The contributors give no express warranties,</span>
<span class="cm">guarantees or conditions. You may have additional consumer</span>
<span class="cm">rights under your local laws which this license cannot change.</span>
<span class="cm">To the extent permitted under your local laws, the contributors</span>
<span class="cm">exclude the implied warranties of merchantability, fitness for</span>
<span class="cm">a particular purpose and non-infringement.</span>
<span class="cm">*/</span></pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <h3>Helper Includes</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>Vector algebra and common GL machinations that have been isolated for
clarity of the core OSD code.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="cp">#include &quot;algebra.h&quot;</span>
<span class="cp">#include &quot;glhelpers.h&quot;</span></pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <h3>OpenSubdiv Includes</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>The mutex header provides a cross platform mutex implementation; the vertex 
and mesh headers provide abstract representations of verts and meshes; the
element array buffer provides an abstract representation of an index buffer; 
and finally, the cpu dispatcher is how subdivision work is dispatched to the CPU.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="cp">#include &lt;osd/mutex.h&gt;</span>
<span class="cp">#include &lt;osd/vertex.h&gt;</span>
<span class="cp">#include &lt;osd/mesh.h&gt;</span>
<span class="cp">#include &lt;osd/elementArrayBuffer.h&gt;</span>
<span class="cp">#include &lt;osd/cpuDispatcher.h&gt;</span></pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <h3>Global Variables &amp; Declarations</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p>The screen width &amp; height; current frame for animation; and the desired 
subdivision level.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">int</span> <span class="n">g_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">g_height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">g_frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">g_level</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span></pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p>A center point for the view matrix and the object size for framing</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">float</span> <span class="n">g_center</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">},</span>
      <span class="n">g_size</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span></pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>The OSD state: a mesh, vertex buffer and element array</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdMesh</span> <span class="o">*</span> <span class="n">g_osdmesh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdVertexBuffer</span><span class="o">*</span> <span class="n">g_vertexBuffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdElementArrayBuffer</span> <span class="o">*</span><span class="n">g_elementArrayBuffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>The coarse mesh positions and normals are saved externally and deformed during
playback.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">g_orgPositions</span><span class="p">,</span>
                   <span class="n">g_normals</span><span class="p">;</span></pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p>Forward declarations. These functions will be described below as they are 
defined.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">void</span> <span class="n">idle</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">reshape</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">createOsdMesh</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kernel</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">updateGeom</span><span class="p">();</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">calcNormals</span><span class="p">(</span><span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrMesh</span> <span class="o">*</span> <span class="n">mesh</span><span class="p">,</span> 
                        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> 
                        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">result</span> <span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <h3>The main program entry point</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <p>Not much to see here: do glut initialization, register the Osd CPU kernel, 
call createOsdMesh (see below), init glew and one-time GL state and enter the
main glut loop.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">glutInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">glutInitDisplayMode</span><span class="p">(</span><span class="n">GLUT_RGBA</span> <span class="o">|</span><span class="n">GLUT_DOUBLE</span> <span class="o">|</span> <span class="n">GLUT_DEPTH</span><span class="p">);</span>
    <span class="n">glutInitWindowSize</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
    <span class="n">glutCreateWindow</span><span class="p">(</span><span class="s">&quot;CPU Subdivision Example&quot;</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-14">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-14">&#182;</a>               </div>               <p>Dispatchers are created from a kernel enumeration via the factory pattern,
calling register here ensures that the CPU dispatcher will be available
for construction when it is requested via the kCPU enumeration inside the
function createOsdMesh.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdCpuKernelDispatcher</span><span class="o">::</span><span class="n">Register</span><span class="p">();</span></pre></div>             </td>           </tr>                               <tr id="section-15">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-15">&#182;</a>               </div>               <p>Setup glut, glew and some initial GL state</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">glutDisplayFunc</span><span class="p">(</span><span class="n">display</span><span class="p">);</span>
    <span class="n">glutReshapeFunc</span><span class="p">(</span><span class="n">reshape</span><span class="p">);</span>
    <span class="n">glutIdleFunc</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
    <span class="n">glewInit</span><span class="p">();</span>
    <span class="n">initGL</span><span class="p">();</span></pre></div>             </td>           </tr>                               <tr id="section-16">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-16">&#182;</a>               </div>               <p>The following method will populate the g_osdMesh object, which will 
contain the precomputed subdivision tables.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">createOsdMesh</span><span class="p">(</span><span class="n">g_level</span><span class="p">,</span> 
                  <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdKernelDispatcher</span><span class="o">::</span><span class="n">kCPU</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-17">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-17">&#182;</a>               </div>               <p>Start the main glut drawing loop</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">glutMainLoop</span><span class="p">();</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-18">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-18">&#182;</a>               </div>               <h3>Construct the OSD Mesh</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-19">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-19">&#182;</a>               </div>               <p>Here is where the real meat of the OSD setup happens. The mesh topology is 
created and stored for later use. Actual subdivision happens in updateGeom 
which gets called at the end of this function and on frame change.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">void</span>
<span class="n">createOsdMesh</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kernel</span><span class="p">)</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-20">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-20">&#182;</a>               </div>               <p>Setup an OsdHbr mesh based on the desired subdivision scheme</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="k">static</span> <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">HbrCatmarkSubdivision</span><span class="o">&lt;</span><span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdVertex</span><span class="o">&gt;</span>  <span class="n">_catmark</span><span class="p">;</span>
    <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrMesh</span> <span class="o">*</span> <span class="n">hmesh</span><span class="p">(</span><span class="k">new</span> <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrMesh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_catmark</span><span class="p">));</span></pre></div>             </td>           </tr>                               <tr id="section-21">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-21">&#182;</a>               </div>               <p>Now that we have a mesh, we need to add verticies and define the topology.
Here, we've declared the raw vertex data in-line, for simplicity</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="kt">float</span> <span class="n">verts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>    <span class="mf">0.000000</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.414214</span><span class="p">,</span> <span class="mf">1.000000</span><span class="p">,</span>
                        <span class="mf">1.414214</span><span class="p">,</span> <span class="mf">0.000000</span><span class="p">,</span> <span class="mf">1.000000</span><span class="p">,</span>
                        <span class="o">-</span><span class="mf">1.414214</span><span class="p">,</span> <span class="mf">0.000000</span><span class="p">,</span> <span class="mf">1.000000</span><span class="p">,</span>
                        <span class="mf">0.000000</span><span class="p">,</span> <span class="mf">1.414214</span><span class="p">,</span> <span class="mf">1.000000</span><span class="p">,</span>
                        <span class="o">-</span><span class="mf">1.414214</span><span class="p">,</span> <span class="mf">0.000000</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.000000</span><span class="p">,</span>
                        <span class="mf">0.000000</span><span class="p">,</span> <span class="mf">1.414214</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.000000</span><span class="p">,</span>
                        <span class="mf">0.000000</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.414214</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.000000</span><span class="p">,</span>
                        <span class="mf">1.414214</span><span class="p">,</span> <span class="mf">0.000000</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.000000</span>
                        <span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-22">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-22">&#182;</a>               </div>               <p>The cube faces are also in-lined, here they are specified as quads</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="kt">int</span> <span class="n">faces</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span>
                        <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span>
                        <span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span>
                        <span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
                        <span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>
                        <span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span>
                        <span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-23">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-23">&#182;</a>               </div>               <p>Record the original vertex positions and add verts to the mesh.</p>

<p>OsdVertex is really just a place holder, it doesn't care what the 
position of the vertex is, it's just being used here as a means of
defining the mesh topology.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g_orgPositions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">g_orgPositions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">g_orgPositions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]);</span>
        
        <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdVertex</span> <span class="n">vert</span><span class="p">;</span>
        <span class="n">hmesh</span><span class="o">-&gt;</span><span class="n">NewVertex</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">vert</span><span class="p">);</span>
    <span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-24">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-24">&#182;</a>               </div>               <p>Now specify the actual mesh topology by processing the faces array </p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">VERTS_PER_FACE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">VERTS_PER_FACE</span><span class="p">)</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-25">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-25">&#182;</a>               </div>               <p>Do some sanity checking. It is a good idea to keep this in your 
code for your personal sanity as well.</p>

<p>Note that this loop is not changing the HbrMesh, it's purely validating
the topology that is about to be created below.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">VERTS_PER_FACE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrVertex</span> <span class="o">*</span> <span class="n">origin</span>      <span class="o">=</span> <span class="n">hmesh</span><span class="o">-&gt;</span><span class="n">GetVertex</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]);</span>
            <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrVertex</span> <span class="o">*</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">hmesh</span><span class="o">-&gt;</span><span class="n">GetVertex</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">VERTS_PER_FACE</span><span class="p">)]);</span>
            <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrHalfedge</span> <span class="o">*</span> <span class="n">opposite</span>  <span class="o">=</span> <span class="n">destination</span><span class="o">-&gt;</span><span class="n">GetEdge</span><span class="p">(</span><span class="n">origin</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">origin</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">||</span> <span class="n">destination</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> 
                    <span class="s">&quot; An edge was specified that connected a nonexistent vertex&quot;</span>
                    <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">(</span><span class="n">origin</span> <span class="o">==</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> 
                    <span class="s">&quot; An edge was specified that connected a vertex to itself&quot;</span> 
                    <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">(</span><span class="n">opposite</span> <span class="o">&amp;&amp;</span> <span class="n">opposite</span><span class="o">-&gt;</span><span class="n">GetOpposite</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> 
                    <span class="s">&quot; A non-manifold edge incident to more than 2 faces was found&quot;</span> 
                    <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">(</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">GetEdge</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> 
                    <span class="s">&quot; An edge connecting two vertices was specified more than once.&quot;</span>
                    <span class="s">&quot; It&#39;s likely that an incident face was flipped&quot;</span> 
                    <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-26">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-26">&#182;</a>               </div>               <p>Now, create current face given the number of verts per face and the 
face index data.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrFace</span> <span class="o">*</span> <span class="n">face</span> <span class="o">=</span> <span class="n">hmesh</span><span class="o">-&gt;</span><span class="n">NewFace</span><span class="p">(</span><span class="n">VERTS_PER_FACE</span><span class="p">,</span> <span class="n">faces</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span></pre></div>             </td>           </tr>                               <tr id="section-27">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-27">&#182;</a>               </div>               <p>If you had ptex data, you would set it here, for example</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="cm">/* face-&gt;SetPtexIndex(ptexIndex) */</span>

    <span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-28">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-28">&#182;</a>               </div>               <p>Apply some tags to drive the subdivision algorithm. Here we set the 
default boundary interpolation mode along with a corner sharpness. See 
the API and the renderman spec for the full list of available operations.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">hmesh</span><span class="o">-&gt;</span><span class="n">SetInterpolateBoundaryMethod</span><span class="p">(</span> <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrMesh</span><span class="o">::</span><span class="n">k_InterpolateBoundaryEdgeOnly</span> <span class="p">);</span>
    
    <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrVertex</span> <span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="n">hmesh</span><span class="o">-&gt;</span><span class="n">GetVertex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">SetSharpness</span><span class="p">(</span><span class="mf">2.7f</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-29">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-29">&#182;</a>               </div>               <p>Finalize the mesh object. The Finish() call is a signal to the internals 
that optimizations can be made on the mesh data. </p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">hmesh</span><span class="o">-&gt;</span><span class="n">Finish</span><span class="p">();</span></pre></div>             </td>           </tr>                               <tr id="section-30">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-30">&#182;</a>               </div>               <p>Setup some raw vectors of data. Remember that the actual point values were
not stored in the OsdVertex, so we keep track of them here instead</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">g_normals</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">g_orgPositions</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="mf">0.0f</span><span class="p">);</span>
    <span class="n">calcNormals</span><span class="p">(</span> <span class="n">hmesh</span><span class="p">,</span> <span class="n">g_orgPositions</span><span class="p">,</span> <span class="n">g_normals</span> <span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-31">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-31">&#182;</a>               </div>               <p>At this point, we no longer need the topological structure of the mesh, 
so we bake it down into subdivision tables by converting the HBR mesh 
into an OSD mesh. Note that this is just storing the initial subdivision
tables, which will be used later during the actual subdivision process.</p>

<p>Again, no vertex positions are being stored here, the point data will be 
sent to the mesh in updateGeom().</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">g_osdmesh</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdMesh</span><span class="p">();</span>
    <span class="n">g_osdmesh</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="n">hmesh</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">kernel</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">hmesh</span><span class="p">;</span></pre></div>             </td>           </tr>                               <tr id="section-32">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-32">&#182;</a>               </div>               <p>Initialize the index and vertex buffers</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">g_elementArrayBuffer</span> <span class="o">=</span> <span class="n">g_osdmesh</span><span class="o">-&gt;</span><span class="n">CreateElementArrayBuffer</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="n">g_vertexBuffer</span> <span class="o">=</span> <span class="n">g_osdmesh</span><span class="o">-&gt;</span><span class="n">InitializeVertexBuffer</span><span class="p">(</span><span class="mi">6</span> <span class="cm">/* 3 floats for position, </span>
<span class="cm">                                                            +</span>
<span class="cm">                                                            3 floats for normal*/</span>
                                                        <span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-33">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-33">&#182;</a>               </div>               <p>Setup camera positioning based on object bounds. This really has nothing
to do with OSD.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">computeCenterAndSize</span><span class="p">(</span><span class="n">g_orgPositions</span><span class="p">,</span> <span class="n">g_center</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_size</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-34">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-34">&#182;</a>               </div>               <p>Finally, make an explicit call to updateGeom() to force creation of the 
initial buffer objects for the first draw call.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">updateGeom</span><span class="p">();</span></pre></div>             </td>           </tr>                               <tr id="section-35">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-35">&#182;</a>               </div>               <p>The OsdVertexBuffer provides GL identifiers which can be bound in the 
standard way. Here we setup a single VAO and enable points and normals 
as attributes on the vertex buffer and set the index buffer.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">GLuint</span> <span class="n">vao</span><span class="p">;</span>
    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vao</span><span class="p">);</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">g_vertexBuffer</span><span class="o">-&gt;</span><span class="n">GetGpuBuffer</span><span class="p">());</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GLfloat</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GLfloat</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="mi">12</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">g_elementArrayBuffer</span><span class="o">-&gt;</span><span class="n">GetGlBuffer</span><span class="p">());</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-36">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-36">&#182;</a>               </div>               <h3>Update Geometry and Subdivide</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-37">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-37">&#182;</a>               </div>               <p>This is where the magic happens. Given the initial subdivision table stored 
in the OsdMesh, on every frame we can now send coarse point position updates 
and recompute the subdivided surface based on the coarse animation.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">void</span>
<span class="n">updateGeom</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">nverts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">g_orgPositions</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">vertex</span><span class="p">;</span>
    <span class="n">vertex</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">nverts</span><span class="o">*</span><span class="mi">6</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">g_orgPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">g_normals</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span></pre></div>             </td>           </tr>                               <tr id="section-38">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-38">&#182;</a>               </div>               <p>Apply a simple deformer to the coarse mesh. We save the deformed points 
and normals into a separate buffer to avoid accumulation of error. This 
loop really has nothing to do with OSD.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">g_frame</span><span class="o">*</span><span class="mf">0.001f</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nverts</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">move</span> <span class="o">=</span> <span class="mf">0.05f</span><span class="o">*</span><span class="n">cosf</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">20</span><span class="o">+</span><span class="n">g_frame</span><span class="o">*</span><span class="mf">0.01f</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">st</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">);</span>
        
        <span class="n">vertex</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ct</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">st</span><span class="p">);</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">st</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ct</span><span class="p">);</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span></pre></div>             </td>           </tr>                               <tr id="section-39">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-39">&#182;</a>               </div>               <p>To be completely accurate, we should deform the normals here too, but
the original undeformed normals are sufficient for this example </p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="n">vertex</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
 
        <span class="n">p</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-40">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-40">&#182;</a>               </div>               <p>Send the animated coarse positions and normals to the vertex buffer.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">g_vertexBuffer</span><span class="o">-&gt;</span><span class="n">UpdateData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nverts</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-41">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-41">&#182;</a>               </div>               <p>Dispatch subdivision work based on the coarse vertex buffer. At this 
point, the assigned dispatcher will queue up work, potentially in many
worker threads. If the subdivided data is required for further processing
a call to Synchronize() will allow you to block until the worker threads
complete.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">g_osdmesh</span><span class="o">-&gt;</span><span class="n">Subdivide</span><span class="p">(</span><span class="n">g_vertexBuffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-42">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-42">&#182;</a>               </div>               <p>The call to Synchronize() is not actually necessary, it's being used
here only for illustration. </p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">g_osdmesh</span><span class="o">-&gt;</span><span class="n">Synchronize</span><span class="p">();</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-43">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-43">&#182;</a>               </div>               <h3>Calculate Face Normals</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-44">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-44">&#182;</a>               </div>               <p>A helper function to calculate face normals. It is included here to illustrate
how to inspect the coarse mesh, give an HbrMesh pointer.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="n">calcNormals</span><span class="p">(</span><span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrMesh</span> <span class="o">*</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">result</span> <span class="p">)</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-45">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-45">&#182;</a>               </div>               <p>Get the number of vertices and faces. Notice the naming convention is 
different between coarse Vertices and Faces. This may change in the 
future (it an artifact of the original renderman code).</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="kt">int</span> <span class="n">nverts</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">GetNumVertices</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">nfaces</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">GetNumCoarseFaces</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfaces</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">OpenSubdiv</span><span class="o">::</span><span class="n">OsdHbrFace</span> <span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">GetFace</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="kt">float</span> <span class="k">const</span> <span class="o">*</span> <span class="n">p0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">GetVertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetID</span><span class="p">()</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span>
                    <span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">GetVertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetID</span><span class="p">()</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span>
                    <span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">GetVertex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetID</span><span class="p">()</span><span class="o">*</span><span class="mi">3</span><span class="p">];</span>

        <span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">cross</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">GetNumVertices</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">GetVertex</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetID</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="n">idx</span>  <span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nverts</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">normalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-46">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-46">&#182;</a>               </div>               <h3>Misc. GLUT Callback Methods</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-47">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-47">&#182;</a>               </div>               <p>Reshape is called when the window is resized, here we need the width and 
height so that we can correctly adjust the aspect ratio of the projection
matrix.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">void</span>
<span class="n">reshape</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">g_height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-48">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-48">&#182;</a>               </div>               <p>Idle is called between frames, here we advance the frame number and update
the procedural animation that is being applied to the mesh</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">void</span>
<span class="n">idle</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">g_frame</span><span class="o">++</span><span class="p">;</span>
    <span class="n">updateGeom</span><span class="p">();</span>
    <span class="n">glutPostRedisplay</span><span class="p">();</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-49">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-49">&#182;</a>               </div>               <h3>Draw the Mesh</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-50">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-50">&#182;</a>               </div>               <p>Display handles all drawing per frame. We first call the setupForDisplay 
helper method to setup some uninteresting GL state and then bind the mesh
using the buffers provided by our OSD objects</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kt">void</span>
<span class="n">display</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">setupForDisplay</span><span class="p">(</span><span class="n">g_width</span><span class="p">,</span> <span class="n">g_height</span><span class="p">,</span> <span class="n">g_size</span><span class="p">,</span> <span class="n">g_center</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-51">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-51">&#182;</a>               </div>               <p>Bind the GL vertex and index buffers</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">g_vertexBuffer</span><span class="o">-&gt;</span><span class="n">GetGpuBuffer</span><span class="p">());</span></pre></div>             </td>           </tr>                               <tr id="section-52">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-52">&#182;</a>               </div>               <p>Bind the solid shaded program and draw elements based on the buffer contents</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">bindProgram</span><span class="p">(</span><span class="n">g_quadFillProgram</span><span class="p">);</span>
    <span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_LINES_ADJACENCY</span><span class="p">,</span> <span class="n">g_elementArrayBuffer</span><span class="o">-&gt;</span><span class="n">GetNumIndices</span><span class="p">(),</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-53">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-53">&#182;</a>               </div>               <p>Draw the wire frame over the solid shaded mesh</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">bindProgram</span><span class="p">(</span><span class="n">g_quadLineProgram</span><span class="p">);</span>
    <span class="n">glProgramUniform4f</span><span class="p">(</span><span class="n">g_quadLineProgram</span><span class="p">,</span> 
                       <span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">g_quadLineProgram</span><span class="p">,</span> <span class="s">&quot;fragColor&quot;</span><span class="p">),</span> 
                       <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_LINES_ADJACENCY</span><span class="p">,</span> <span class="n">g_elementArrayBuffer</span><span class="o">-&gt;</span><span class="n">GetNumIndices</span><span class="p">(),</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-54">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-54">&#182;</a>               </div>               <p>This isn't strictly necessary, but unbind the GL state</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">glUseProgram</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-55">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-55">&#182;</a>               </div>               <p>Draw the HUD/status text</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">glColor3f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">drawString</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&quot;LEVEL = %d&quot;</span><span class="p">,</span> <span class="n">g_level</span><span class="p">);</span>
    <span class="n">drawString</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;# of Vertices = %d&quot;</span><span class="p">,</span> <span class="n">g_osdmesh</span><span class="o">-&gt;</span><span class="n">GetFarMesh</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetNumVertices</span><span class="p">());</span>
    <span class="n">drawString</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&quot;KERNEL = CPU&quot;</span><span class="p">);</span>
    <span class="n">drawString</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="s">&quot;SUBDIVISION = %s&quot;</span><span class="p">,</span> <span class="s">&quot;CATMARK&quot;</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-56">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-56">&#182;</a>               </div>               <p>Finish the current frame</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="n">glFinish</span><span class="p">();</span>
    <span class="n">glutSwapBuffers</span><span class="p">();</span>
<span class="p">}</span>

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 